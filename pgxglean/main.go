// A Postgres SQL read query boilerplate generator

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"html/template"
	"os"

	"github.com/rossmacarthur/fudge"
	"github.com/rossmacarthur/fudge/errors"
	"golang.org/x/term"
)

var (
	table  = flag.String("table", "", "the table name to query")
	output = flag.String("output", "glean_gen.go", "the output path")
)

type Config struct {
	// Name is the name of the package containing the glean struct
	PackageName string
	// GenSource is the location of the go:generate call
	GenSource string
	// BackTick is simply the backtick character
	BackTick string
	// TableName is the name of the table to query
	TableName string
	// OutputType is the full name of the output type struct
	OutputType string
	// OutputImport is the path to import the output type struct
	OutputImport string
	// Fields is the list of fields to query
	Fields []Field
}

type Field struct {
	// Name is the Name of the field in the glean or embedded struct
	Name string
	// Column is the name of the column in the database
	Column string
	// Accessor is the field or method to use when constructing the output struct
	Accessor string
	// If this is the first field
	First bool
}

func main() {
	flag.Parse()

	if *table == "" {
		fatalErr(errors.New("--table is required"))
	}

	cfg, err := parseConfig()
	if err != nil {
		fatalErr(errors.Wrap(err, "failed to parse config"))
	}

	err = generate(cfg)
	if err != nil {
		fatalErr(errors.Wrap(err, "failed to generate code"))
	}
}

func fatalErr(err error) {
	isAtty := term.IsTerminal(int(os.Stdout.Fd()))
	var colorRed, colorBold, colorReset string
	if isAtty {
		colorRed = "\033[1;31m"
		colorBold = "\033[1m"
		colorReset = "\033[0m"
	}

	if e, ok := err.(*errors.Error); ok {
		fmt.Fprintf(os.Stderr, "%serror:%s ", colorRed, colorReset)
		first := true
		e.FormatCustom(func(msg string) {
			if first {
				fmt.Fprintf(os.Stderr, "%s\n", msg)
				first = false
			} else {
				fmt.Fprintf(os.Stderr, "  %sdue to:%s %s\n", colorBold, colorReset, msg)
			}
		})
	} else {
		fmt.Fprintf(os.Stderr, "%serror:%s %s\n", colorRed, colorReset, err)
	}

	os.Exit(1)
}

func generate(cfg *Config) error {
	var out bytes.Buffer
	t, err := template.New(*output).Parse(tmpl)
	if err != nil {
		return errors.Wrap(err, "failed to parse template")
	}

	err = t.Execute(&out, cfg)
	if err != nil {
		return errors.Wrap(err, "failed to render template")
	}

	bs, err := format.Source(out.Bytes())
	if err != nil {
		return errors.Wrap(err, "failed to format")
	}

	err = os.WriteFile(*output, bs, 0644)
	if err != nil {
		return errors.Wrap(err, "failed to write file", fudge.KV("path", *output))
	}

	return err
}

const tmpl = `package {{.PackageName}}
{{if .GenSource}}
// Code generated by pgxglean from {{.GenSource}}. DO NOT EDIT
{{else}}
// Code generated by pgxglean. DO NOT EDIT.
{{end}}
import (
	"context"

	"github.com/jackc/pgx/v5"

	{{ if .OutputImport }}"{{ .OutputImport }}"{{ end }}
)

const cols = {{ $.BackTick }} {{ range .Fields }}{{ if not .First }}, {{ end }}"{{ .Column }}"{{ end }} {{ $.BackTick }}

func Lookup(ctx context.Context, dbc DB, id int64) (*{{ .OutputType }}, error) {
	return lookupWhere(ctx, dbc, "id = $1", id)
}

func lookupWhere(ctx context.Context, dbc DB, where string, args ...any) (*{{ .OutputType }}, error) {
	row := dbc.QueryRow(ctx, "SELECT"+cols+"FROM {{.TableName}} WHERE "+where, args...)
	return scan(row)
}

func listWhere(ctx context.Context, dbc DB, where string, args ...any) ([]{{ .OutputType }}, error) {
	rows, err := dbc.Query(ctx, "SELECT"+cols+"FROM {{.TableName}} WHERE "+where, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []{{ .OutputType }}

	for rows.Next() {
		o, err := scan(rows)
		if err != nil {
			return nil, err
		}
		out = append(out, *o)
	}

	return out, nil
}

func scan(row pgx.Row) (*{{ .OutputType }}, error) {
	var g glean

	err := row.Scan({{ range .Fields }}
		&g.{{ .Name }},{{ end }}
	)
	if err != nil {
		return nil, err
	}

	return &{{.OutputType}}{ {{range .Fields}}
		{{ .Name }}: g.{{ .Name }}{{ .Accessor }},{{ end }}
	}, nil
}

type DB interface {
	Query(context.Context, string, ...any) (pgx.Rows, error)
	QueryRow(context.Context, string, ...any) pgx.Row
}
`
